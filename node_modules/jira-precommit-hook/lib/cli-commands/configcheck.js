'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _objectDestructuringEmpty2 = require('babel-runtime/helpers/objectDestructuringEmpty');

var _objectDestructuringEmpty3 = _interopRequireDefault(_objectDestructuringEmpty2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.fileFilter = fileFilter;

var _fsPromise = require('fs-promise');

var _fsPromise2 = _interopRequireDefault(_fsPromise);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var command = 'configcheck';

function recursiveWalk(dir) {
  var results = []; // eslint-disable-line no-var
  var list = _fs2.default.readdirSync(dir); // eslint-disable-line no-var
  list.forEach(function (file) {
    var newfile = _path2.default.join(dir, file);
    var stat = _fs2.default.lstatSync(newfile);
    if (stat && stat.isDirectory()) {
      results = results.concat(recursiveWalk(newfile));
    } else {
      results.push(newfile);
    }
  });
  return results;
}

function fileFilter(filename) {
  var regexPatterns = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (regexPatterns.length === 0) {
    return true;
  }

  var actualResult = regexPatterns.some(function (x) {
    return filename.match(x);
  });
  return actualResult;
}

exports.default = {
  command: command,
  execute: function execute(_ref) {
    var _this = this;

    (0, _objectDestructuringEmpty3.default)(_ref);
    return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
      var workingDirectory, deploymentConfigPath, fileResult, jsonResult, fileList, collectorMap, allRegexPatterns;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.log('Checking hubot-deployments-config.json...');
              workingDirectory = process.cwd();
              deploymentConfigPath = _path2.default.join(workingDirectory, 'hubot-deployments-config.json');

              if (_fs2.default.existsSync(deploymentConfigPath)) {
                _context.next = 6;
                break;
              }

              console.warn(deploymentConfigPath + ' does not exist.');
              return _context.abrupt('return', 1);

            case 6:
              _context.next = 8;
              return _fsPromise2.default.readFile(deploymentConfigPath);

            case 8:
              fileResult = _context.sent;
              _context.prev = 9;

              jsonResult = JSON.parse(fileResult);
              _context.next = 17;
              break;

            case 13:
              _context.prev = 13;
              _context.t0 = _context['catch'](9);

              console.error('hubot-deployments-config.json is not a valid JSON file. ' + _context.t0.message);
              return _context.abrupt('return', 1);

            case 17:

              console.log('hubot-deployments-config.json is valid JSON.  Showing debug file list...');
              fileList = recursiveWalk(workingDirectory);
              collectorMap = {};
              allRegexPatterns = [];


              (0, _keys2.default)(jsonResult).forEach(function (buildType) {
                allRegexPatterns.push(jsonResult[buildType]);
                collectorMap[buildType] = fileList.filter(function (x) {
                  return fileFilter(x, jsonResult[buildType]);
                });
              });

              console.log('Results:');
              (0, _keys2.default)(collectorMap).forEach(function (buildType) {
                console.log('Files Associated with ' + buildType + ':');
                console.log(collectorMap[buildType]);
              });
              console.log('Uncovered Files:');
              console.log(fileList.filter(function (x) {
                return !fileFilter(x, allRegexPatterns);
              }));
              return _context.abrupt('return', 0);

            case 27:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this, [[9, 13]]);
    }))();
  },
  register: function register(subparsers) {
    subparsers.addParser(command, {
      addHelp: true,
      help: command + ' help'
    });
  }
};